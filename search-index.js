var searchIndex = new Map(JSON.parse('[\
["ladderz",{"doc":"ladderz","t":"CCHHHHHHHHHHHH","n":["dsa","prealgebra","contains_duplicate","is_anagram","is_anagram2","get_factor_pairs","get_factors","get_multiples_in_range","get_prime_factorization","get_primes_in_range","is_composite","is_factor","is_multiple","is_prime"],"q":[[0,"ladderz"],[2,"ladderz::dsa"],[5,"ladderz::prealgebra"],[14,"alloc::vec"],[15,"alloc::string"],[16,"std::collections::hash::set"],[17,"std::collections::hash::map"]],"d":["Various data structures and algorithms implementations.","Various pre-algebra implementations including factor …","","","","Finds all factor pairs for a positive integer <code>n</code>.","Finds all factors of a positive integer <code>n</code>.","Finds all the multiples of a positive integer <code>n</code> starting …","Returns the prime factorization of a positive integer <code>n</code>.","Returns all prime numbers in the range [start, end].","Checks if a positive integer <code>n</code> is a composite number.","Checks if a positive integer <code>x</code> is a factor of another …","Checks if a positive integer <code>x</code> is a multiple of another …","Checks if a positive integer <code>n</code> is a prime number."],"i":[0,0,0,0,0,0,0,0,0,0,0,0,0,0],"f":[0,0,[[[2,[1]]],3],[[4,4],3],[[4,4],3],[5,[[7,[[6,[5,5]]]]]],[5,[[7,[5]]]],[[5,5,5],[[7,[5]]]],[5,[[8,[5,5]]]],[[5,5],[[7,[5]]]],[5,3],[[5,5],3],[[5,5],3],[5,3]],"c":[],"p":[[1,"i32"],[5,"Vec",14],[1,"bool"],[5,"String",15],[1,"u32"],[1,"tuple"],[5,"HashSet",16],[5,"HashMap",17]],"b":[]}],\
["lz",{"doc":"lz","t":"FPPGNNNNNNNNNNCNNNNNNNNNNHCONNNNNNNNNNOOPGPNNNNNNNNNHNNNNNOOOOOPPPPPPPGPPNNNNNNNNNHNNNNNOOOOOOOOOOOOOOOOOOOOOOO","n":["Cli","Dsa","Prealgebra","Subjects","augment_args","augment_args_for_update","augment_subcommands","augment_subcommands_for_update","borrow","borrow","borrow_mut","borrow_mut","command","command_for_update","dsa","from","from","from_arg_matches","from_arg_matches","from_arg_matches_mut","from_arg_matches_mut","group_id","has_subcommand","into","into","main","prealgebra","subject","try_from","try_from","try_into","try_into","type_id","type_id","update_from_arg_matches","update_from_arg_matches","update_from_arg_matches_mut","update_from_arg_matches_mut","function","function","ContainsDuplicate","Dsa","IsAnagram","augment_subcommands","augment_subcommands_for_update","borrow","borrow_mut","from","from_arg_matches","from_arg_matches_mut","has_subcommand","into","match_dsa","try_from","try_into","type_id","update_from_arg_matches","update_from_arg_matches_mut","a","b","n","raw","raw","FactorPairs","Factors","IsComposite","IsFactor","IsMultiple","IsPrime","MultiplesInRange","Prealgebra","PrimeFactorization","PrimesInRange","augment_subcommands","augment_subcommands_for_update","borrow","borrow_mut","from","from_arg_matches","from_arg_matches_mut","has_subcommand","into","match_prealgebra","try_from","try_into","type_id","update_from_arg_matches","update_from_arg_matches_mut","lower_bound","lower_bound","m","m","n","n","n","n","n","n","n","n","raw","raw","raw","raw","raw","raw","raw","raw","raw","upper_bound","upper_bound"],"q":[[0,"lz"],[38,"lz::Subjects"],[40,"lz::dsa"],[58,"lz::dsa::Dsa"],[63,"lz::prealgebra"],[88,"lz::prealgebra::Prealgebra"],[111,"clap_builder::builder::command"],[112,"clap_builder::parser::matches::arg_matches"],[113,"clap_builder"],[114,"core::result"],[115,"clap_builder::util::id"],[116,"core::option"],[117,"core::any"]],"d":["","","","The subjects that can be used.","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","The function (command) to run.","","Returns true or false based on whether the vector has a …","","Returns true or false based on whether string a is an …","","","","","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","","","","","","","The first string to compare against.","The second string to compare against.","The vector of numbers to detect whether it has a duplicate.","Whether or not to return the raw output.","Whether or not to return the raw output.","Finds all factor pairs for a positive integer.","Finds all factors for a positive integer.","Determines if a positive integer is composite.","Determines if a positive integer is a factor of another …","Determines if a positive integer is a multiple of another …","Determines if a positive integer is prime.","Finds all multiples of a positive integer in a given range.","","Finds the prime factorization of a positive integer.","Finds all primes in a given range.","","","","","Returns the argument unchanged.","","","","Calls <code>U::from(self)</code>.","","","","","","","The lower bound of the range to find multiples in.","The lower bound of the range to find primes in.","The positive integer to determine if it is a multiple.","The positive integer to determine if it is a factor.","The positive integer to find factor pairs for.","The positive integer to find factors for.","The positive integer to find multiples for.","The positive integer to find the prime factorization of.","The positive integer to determine if it is composite.","The positive integer to determine if it is prime.","The positive integer to determine if it is a factor.","The positive integer to determine if it is a multiple.","Whether or not to return the raw output.","Whether or not to return the raw output.","Whether or not to return the raw output.","Whether or not to return the raw output.","Whether or not to return the raw output.","Whether or not to return the raw output.","Whether or not to return the raw output.","Whether or not to return the raw output.","Whether or not to return the raw output.","The upper bound of the range to find multiples in.","The upper bound of the range to find primes in."],"i":[0,6,6,0,3,3,6,6,3,6,3,6,3,3,0,3,6,3,6,3,6,3,6,3,6,0,0,3,3,6,3,6,3,6,3,6,3,6,15,16,13,0,13,13,13,13,13,13,13,13,13,13,0,13,13,13,13,13,17,17,18,18,17,14,14,14,14,14,14,14,0,14,14,14,14,14,14,14,14,14,14,14,0,14,14,14,14,14,19,20,21,22,23,24,19,25,26,27,21,22,23,24,19,20,25,26,27,21,22,19,20],"f":[0,0,0,0,[1,1],[1,1],[1,1],[1,1],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-2,[],[]],[[],1],[[],1],0,[-1,-1,[]],[-1,-1,[]],[2,[[5,[3,4]]]],[2,[[5,[6,4]]]],[2,[[5,[3,4]]]],[2,[[5,[6,4]]]],[[],[[8,[7]]]],[9,10],[-1,-2,[],[]],[-1,-2,[],[]],[[],11],0,0,[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,12,[]],[-1,12,[]],[[3,2],[[5,[11,4]]]],[[6,2],[[5,[11,4]]]],[[3,2],[[5,[11,4]]]],[[6,2],[[5,[11,4]]]],0,0,0,0,0,[1,1],[1,1],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-1,[]],[2,[[5,[13,4]]]],[2,[[5,[13,4]]]],[9,10],[-1,-2,[],[]],[[[8,[13]]],11],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,12,[]],[[13,2],[[5,[11,4]]]],[[13,2],[[5,[11,4]]]],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[1,1],[1,1],[-1,-2,[],[]],[-1,-2,[],[]],[-1,-1,[]],[2,[[5,[14,4]]]],[2,[[5,[14,4]]]],[9,10],[-1,-2,[],[]],[[[8,[14]]],11],[-1,[[5,[-2]]],[],[]],[-1,[[5,[-2]]],[],[]],[-1,12,[]],[[14,2],[[5,[11,4]]]],[[14,2],[[5,[11,4]]]],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"c":[],"p":[[5,"Command",111],[5,"ArgMatches",112],[5,"Cli",0],[8,"Error",113],[6,"Result",114],[6,"Subjects",0],[5,"Id",115],[6,"Option",116],[1,"str"],[1,"bool"],[1,"tuple"],[5,"TypeId",117],[6,"Dsa",40],[6,"Prealgebra",63],[15,"Prealgebra",38],[15,"Dsa",38],[15,"IsAnagram",58],[15,"ContainsDuplicate",58],[15,"MultiplesInRange",88],[15,"PrimesInRange",88],[15,"IsFactor",88],[15,"IsMultiple",88],[15,"FactorPairs",88],[15,"Factors",88],[15,"PrimeFactorization",88],[15,"IsComposite",88],[15,"IsPrime",88]],"b":[]}]\
]'));
if (typeof exports !== 'undefined') exports.searchIndex = searchIndex;
else if (window.initSearch) window.initSearch(searchIndex);
